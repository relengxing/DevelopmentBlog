# Golang学习：数组切片（slice）
上一篇主要是写了些数据类型，其实没啥东西，就随便看看就可以了，和以前的对比一下记忆一下就OK了。
像取反是`^`，没有`double`是`float64`
这些东西快速带过就可以了，写的多了自然就会了，看的多没用。
这一篇写数组切片
数组切片在C语言里是没有的，java里也没有。

## 创建数组切片
创建数组有两种方法：[基于数组](#jump1)，[直接创建](#jump2)
1. <span id="jump1">基于数组</span>
```go
package main
import "fmt"
func main() {
    // 先定义一个数组
    var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    // 基于数组创建一个数组切片
    var mySlice []int = myArray[:5]
    fmt.Println("Elements of myArray: ")
    for _, v := range myArray {
        fmt.Print(v, " ")
    }
    fmt.Println("\nElements of mySlice: ")
    for _, v := range mySlice {
        fmt.Print(v, " ")
    }
    fmt.Println()
}
```
运行结果为：
Elements of myArray:
1 2 3 4 5 6 7 8 9 10
Elements of mySlice:
1 2 3 4 5
基于myArray的所有元素创建数组切片：
`mySlice = myArray[:]`
基于myArray的前5个元素创建数组切片：
`mySlice = myArray[:5]`
基于从第5个元素开始的所有元素创建数组切片：
`mySlice = myArray[5:]`
2. <span id="jump2">直接创建</span>

并非一定要事先准备一个数组才能创建数组切片。 Go语言提供的内置函数make()可以用于
灵活地创建数组切片。下面的例子示范了直接创建数组切片的各种方法。
创建一个初始元素个数为5的数组切片，元素初始值为0：
`mySlice1 := make([]int, 5)`
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
`mySlice2 := make([]int, 5, 10)`
直接创建并初始化包含5个元素的数组切片：
`mySlice3 := []int{1, 2, 3, 4, 5}`
当然，事实上还会有一个匿名数组被创建出来，只是不需要我们来操心而已。
### 遍历数组切片
可以使用for循环来遍历，这里不介绍了，和C语言类似
好可以使用range关键字可以让遍历代码显得更整洁。 range表达式有两个返回值，第一个是索引，第二个是元素的值：
for i, v := range mySlice {
    fmt.Println("mySlice[", i, "] =", v)
}
## 动态增减元素
可动态增减元素是数组切片比数组更为强大的功能。与数组相比，数组切片多了一个存储能力（capacity）的概念，即元素个数和分配的空间可以是两个不同的值。合理地设置存储能力的值，可以大幅降低数组切片内部重新分配内存和搬送内存块的频率，从而大大提高程序性能。

假如你明确知道当前创建的数组切片最多可能需要存储的元素个数为50，那么如果你设置的存储能力小于50，比如20，那么在元素超过20时，底层将会发生至少一次这样的动作——重新分配一块“够大”的内存，并且需要把内容从原来的内存块复制到新分配的内存块，这会产生比较明显的开销。给“够大”这两个字加上引号的原因是系统并不知道多大才是够大，所以只是一个简单的猜测。比如，将原有的内存空间扩大两倍，但两倍并不一定够，所以之前提到的内存重新分配和内容复制的过程很有可能发生多次，从而明显降低系统的整体性能。但如果你知道最大是50并且一开始就设置存储能力为50，那么之后就不会发生这样非常耗费CPU的动作，从而达到空间换时间的效果。
数组切片支持Go语言内置的cap()函数和len()函数。cap()函数返回的是数组切片分配的空间大小，而len()函数返回的是数组切片中当前所存储的元素个数。

往切片后面添加元素可以使用append()方法
* 在append后面直接添加元素
![使用append](img\4_append添加1.jpg)
* 在append后面添加一个数组,报错
![使用append](img\4_append添加2.jpg)
怎么理解，append后面添加的类型要是int,而slice是数组
解决办法
在slice2后面加三个点
`slice = append(slice,slice2...)`
我们在第二个参数mySlice2后面加了三个点，即一个省略号，如果没有这个省
略号的话，会有编译错误，因为按append()的语义，从第二个参数起的所有参数都是待附加的
元素。因为mySlice中的元素类型为int，所以直接传递mySlice2是行不通的。加上省略号相
当于把mySlice2包含的所有元素打散后传入

### 内容复制

数组切片支持Go语言的另一个内置函数copy()，用于将内容从一个数组切片复制到另一个
数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行
复制。下面的示例展示了copy()函数的行为：
```go
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
```
